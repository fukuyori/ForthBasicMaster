# Lev 5 ー 条件分岐
FORTHのプログラムに「判断」を与える仕組みが条件分岐である。スタックに積まれた値を評価し、結果によって異なる処理を選択する。この回では、`IF ELSE THEN` 構文を中心に、FORTHにおける真理値の扱い方、条件構造の書き方、ネストの設計法、そして条件式を「スタックで考える」感覚を身につける。

## 真理値の考え方

多くの言語では「真＝1」「偽＝0」と表すが、FORTHでは **0が偽（false）**, **−1が真（true）** として扱われる。これはビット単位の論理演算を効率化するための設計であり、真は「全ビットが1」の状態を示す。

ただし、すべての条件判断で「真」とは「偽」以外の値であり、0以外の数値全てが「真」となる。

```
false . \ → 出力: 0
true . \ → 出力: -1
```

例えば：

```
5 3 > .
```

と入力すると、`5 > 3` の比較結果として `-1` が表示される。
逆に、

```
2 8 > .
```

では `0` が返る。
このように、比較ワード（`=`, `<`, `>`, `<=`, `>=`, `<>`, `WITHIN`など）は常にスタック上に真偽値を残す。その真偽値を `IF` 文が参照する、という構造である。

## IF THEN の基本形

FORTHの条件分岐は、スタック上の値をチェックして処理を分ける。

```:構文
( 条件値 -- )
IF     条件が真のときの処理
THEN
```

```:例：正負を判断
: CHECK-SIGN ( n -- )
   0 > IF
      ." Positive" 
   THEN ;
```

```:実行例
5 CHECK-SIGN   → Positive
-3 CHECK-SIGN  → （何も表示されない）
```

`0 >` の結果が `-1`（真）の場合のみ、`IF` の中の処理が実行される。
偽（0）の場合はスキップされ、`THEN`以降に進む。

## ELSE を使った二分岐

`ELSE` を追加すれば、条件に応じた2つの処理を選べる。

```:例：ELSEを使った条件式
: SIGN ( n -- )
   0 > IF
      ." Positive"
   ELSE
      ." Negative or Zero"
   THEN ;
```

```:実行例
3 SIGN    → Positive
0 SIGN    → Negative or Zero
-5 SIGN   → Negative or Zero
```

このように、IF〜ELSE〜THEN の間は順次コンパイルされ、条件の結果によってジャンプ命令が動的に生成される。構文は簡潔だが、コンパイラとしてのFORTHの仕組みをそのまま見せている点が特徴的である。

## 入れ子の条件分岐

FORTHでは`IF`の中に別の`IF`を自由に書ける。ネスト構造の例として、数値を分類するプログラムを見てみよう。

```
: CLASSIFY ( n -- )
   DUP
   0 > IF
      10 > IF
         ." Large Positive"
      ELSE
         ." Small Positive"
      THEN
   ELSE
      0 = IF
         ." Zero"
      ELSE
         ." Negative"
      THEN
   THEN ;
```

```:実行例
15 CLASSIFY → Large Positive
5 CLASSIFY  → Small Positive
0 CLASSIFY  → Zero
-4 CLASSIFY → Negative
```

ネストしたIF構造ではインデントを丁寧に付けることで読みやすくなる。各`THEN`がどの`IF`に対応しているかを明確にすることが、FORTHでは特に重要である。

## スタックで考える条件

条件判定もまた、スタック操作の一種である。
たとえば、次のような構造を見てみよう。

```
: TEST ( a b -- )
   > IF ." a>b" ELSE ." a<=b" THEN ;
```

`a b >` の部分で比較が行われ、結果（0または−1）がスタックに残る。その直後に`IF`がそれを消費し、真偽に応じてジャンプする。つまり「条件式＝スタックを操作して真偽値を生成する手続き」である。これに慣れると、条件判断そのものを一連の演算と同様に“積み重ねて考える”ことができるようになる。

## 複合条件とWITHIN

`WITHIN` は `( n min max -- flag )` というワードで、nが[min,max)の範囲内なら真を返す。

```
: RANGE? ( n -- )
   0 10 WITHIN 
   IF 
       ." In Range" 
   ELSE 
       ." Out of Range" 
   THEN ;
```

これを `AND` を使って書き換えると

```
: RANGE? ( n -- )
   DUP 0 >= AND 10 <=
   IF
      ." In Range"
   ELSE
      ." Out of Range"
   THEN
;
```

複数の条件を組み合わせたい場合は、論理演算ワード `AND`（論理積） `OR`（論理和） `INVERT`（否定） を使う。シンプルだが、範囲判定などの条件式を直感的に書けるFORTHらしい構文である。

## 絶対値関数を作る

これまでの構文を組み合わせて、絶対値を求めるワードを定義してみよう。

```:ワード定義
: ABS ( n -- +n )
   DUP
   0 < IF
      NEGATE
   THEN ;
```


```:実行
-5 ABS .   → 5
7 ABS .    → 7
```

`0 <` が真（−1）なら `NEGATE` が実行される。偽（0）の場合はスキップされ、元の値が残る。

## 条件制御の哲学

FORTHの条件文は、他の言語のように「文（statement）」ではなく「ワード（word）」である。つまり、構文ではなく**定義可能な命令**として存在する。`IF`, `ELSE`, `THEN` はすべて辞書に登録されたワードであり、ユーザーがそれを再定義したり、新しい制御構文を作ることもできる。FORTHでは「制御構文もまた拡張可能な言語の一部」なのだ。

この柔軟さがFORTHの強みであり、システム制御から科学計算まで、用途に合わせて自分自身の制御文を作れる理由である。

## まとめ

FORTHの条件分岐は、シンプルでありながら極めて強力である。

* 真＝−1、偽＝0
* 構文：`IF ... ELSE ... THEN`
* 比較ワード：`=`, `<`, `>`, `WITHIN`
* 条件式もスタック操作の一部

スタックの上に真偽値を積み、`IF`がそれを読む――それがFORTH流の分岐構造である。FORTHでは、条件文すらも「データの流れの中にある一つの変換」に過ぎない。この視点を持てば、プログラムはより単純に、より美しく整理されていくだろう。

