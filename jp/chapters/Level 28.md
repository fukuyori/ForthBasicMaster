# Lev 28 ー 補講５　デバッグとリファクタリング
## 1. なぜ「デバッグとリファクタリング」が Forth で重要か

Forth（特に gforth）は、言語仕様が極めてシンプルであり、実行系・辞書・スタックの構造が"露出された環境"である。そのため、**バグ発見・修正・コード改善のサイクル**が瞬時に回せる。さらに、Forth哲学（語彙を作る／ボトムアップ設計）と相まって、**"書いてみて観察して改善する"** という方式が非常に有効である。

## 2. デバッグを"習慣化"するための5つのチェックポイント

### チェック1：ワード定義時に"スタック効果注記"を必ず記入する

* `: FOO ( x y -- z ) … ;` の形で 「入力」「出力」を文書化。
* 定義時点で書くことで、"書いたものを自分／他人が読める"状態になる。
* これにより後で `.S` との照合がしやすくなり、バグ発生の予防になる。

### チェック2：単体テストを即座に実行できる構造でワードを作る

* 例：`3 4 FOO .` や `5 FOO .S` など。
* 小さくテスト可能な単位を作ることで、変更時の影響範囲を限定できる。

### チェック3：本番並みの入力条件を想定して"境界値テスト"を行う

* 例えば配列アクセスであれば「サイズ0」「サイズ1」「最大サイズ」など。
* Forthではループ・条件分岐を減らす設計が理想だが、境界処理を見逃すと大きなバグ源になる。

### チェック4：スタックの深さ・内容を可視化し、設計とズレがないか確認する

* `.S` を使い、実行中にスタックの個数・内容をモニター。
* 予想した `( x y -- z )` に対して、実際に `( x y -- z w )` のような余分な値が残っていないかチェック。

### チェック5：コードを"意味と構造"で読み返し、不要な副作用・状態変更がないか探す

* グローバル変数・状態フラグ・複数責任のワードを見つけたらリファクタリング対象。
* Forthの理想は「入力 → 処理 → 出力」であり、副作用は最小化。

## 3. リファクタリング：Thinking Forth 的改善フロー

### リファクタリングとは何か？

* 既存のコードの**振る舞いを変えずに**、設計・構造・可読性・再利用性を改善する作業。
* Thinking Forth では「語彙体系の進化 (=言語自体の成長)」として捉えられる。

### リファクタリングのための手順

1. **コードを測定**する

   * 実行時間・スタック深さ・ワード数など。
   * 遅延やスタックの伸び過ぎを"数値化"できれば改善対象が明確。
2. **コードを観察**する

   * スタック図を紙に書く。
   * ワードの責任が1つではない箇所を探す。
3. **抽象化／分割を検討**する

   * 再利用できる断片をワード化。
   * 異なる部分を共通化できないか？
4. **テストを作り直す**

   * 分割・統合後、それぞれのワードに対するテストを再実行。
   * 既存の機能に影響がないかチェック。
5. **統合・最適化**する

   * 高レベル語彙を整理し、読み手の意図が明確になるように。
   * 実行速度・スタック効率を犠牲にしない範囲で改善。

### 注意すべき"リファクタリングの落とし穴"

* リファクタリングだけを先に行い、仕様の理解を置き去りにすると設計が破綻する。
* **"最適化"と"リファクタリング"を混同しないこと**。まず可読性・構造、次に性能である。
* ビッグワードを一気に作って後で分割するより、最初から小ワードを意識すべき。


## 4. デバッグ／リファクタリングを支える技法集

### 技法A：スタック図の運用

* ワードを書く直前に、紙またはコメントでスタック効果を記入。
* 中間処理が複数ある場合、途中のスタック状態をコメントまたは `.S` 出力で明記。
* 実装後、スタック図と `.S` 出力が一致しているかチェック。

### 技法B：ログ出力の活用

* 重要なワード内に `CR ." debug: " .S` などを挿入して、実行時状態を追えるようにする。
* 本番ではこれらを無効化できるよう、条件付きワード（例： `DEBUG? IF … THEN`）にまとめておく。

### 技法C：辞書探索・定義追跡

* `SEE`、`LOCATE`、`WHERE` を使って、どのワードがいつ定義・再定義されたか確認。
* リファクタリング後に"古い語彙が残っていないか"をチェック。
* ワード名変更後、古い名前のエイリアスが残っていないか確認。

### 技法D：ワードの"影響範囲"分析

* あるワードを変更したら、そのワードを呼び出している場所を `WHERE` などで特定。
* 影響が及ぶ範囲が明確なら、テスト範囲を限定できる。
* 呼び出し回数が多いワード＝変更に慎重になるべき。

### 技法E：バージョン管理／コメント履歴

* ワード定義前にコメントで「変更履歴」を簡単に書いておく。
* 変更時には古定義をコメントアウトして残し、「なぜ変えたか」を記録。
* Forthの語彙拡張設計では、この"成長の軌跡"が重要。

## 5. 実践例：改善の流れを追う

```forth:課題コード（改善前）
: PROCESS ( addr n -- sum )
   0                             \ 初期値
   SWAP
   0 DO
      OVER I CELLS + @           \ addr[i]を取得
      DUP 0< IF DROP 0 THEN +    \ 負数を0に、そして加算
   LOOP
   SWAP DROP ;                   \ addrを破棄
```

### 問題点

* ワード名が抽象的 → PROCESS
* 負数クリップ処理がループ内に直書き
* スタック操作が混在（OVER I CELLS + @）
* テストしにくい構造
* 再利用可能な「負数を0にする処理」が埋め込まれたまま


```forth:改善案
\ 基本的な変換ワード
: CLIP-NEG ( n -- n|0 )  0 MAX ;
: FETCH-CELL ( addr i -- n )  CELLS + @ ;

\ 高レベルワード
: SUM-ARRAY ( addr n -- sum )
   0 ROT ROT           \ ( 0 addr n ) 累積値を準備
   0 DO                \ ( sum addr )
      DUP I            \ ( sum addr addr i )
      FETCH-CELL       \ ( sum addr n )
      CLIP-NEG         \ ( sum addr n' )
      ROT + SWAP       \ ( sum' addr )
   LOOP 
   DROP ;              \ ( sum' )
```

### 改善の効果

* 各ワードが単一責任で設計されている
* `CLIP-NEG`・`FETCH-CELL`が他処理でも再利用可能
* `SUM-ARRAY` が意図を示す高レベルワードとして読みやすい
* 各ワードがテスト可能（例：`-5 CLIP-NEG .` や `MYARRAY 3 FETCH-CELL .`）
* スタック効果が明確になり、デバッグが容易となる

### さらなる改善の可能性

もし配列処理が頻繁に発生するなら、さらに抽象化を検討する。そうすることで、同じパターンを他の集約処理にも適用できる。

